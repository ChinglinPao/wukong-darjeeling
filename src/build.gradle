defaultTasks 'darjeeling'
apply plugin: 'c'

// Setup basic configuration parameters
apply from: 'config.gradle'

buildDir = new File(buildDir, djConfigname)
project.ext.djTargetElfFile = "${buildDir}/binaries/darjeelingExecutable/darjeeling"
apply from: 'taskdefs.gradle'

// Helper functions
def ensureEmptyDir(File destDir) {
    if (destDir.exists()) {
        destDir.deleteDir()
    }
    destDir.mkdirs()
}


class CreateDjArchiveTask extends DefaultTask {
    class ArchivePart {
        String filename
        int filetype
    }

    String archiveFile
    def archiveParts = []

    @OutputDirectory
    File destDir

    void addPart(String name, int type, dependsOnTask) {
        def part = new ArchivePart()
        part.filename = name
        part.filetype = type
        archiveParts.add(part)
        inputs.file name
        dependsOn dependsOnTask
    }

    @TaskAction
    void createArchive() {
        project.ensureEmptyDir(destDir)
        boolean first = true
        archiveParts.each { part ->
            println "Adding ${part.filename} to ${archiveFile}"
            ant.djarchive(dest: archiveFile,
                                 src: part.filename,
                                 filetype: part.filetype,
                                 mode: first ? 'create' : 'append')
            first = false
        }
    }
}

// Basic tasks
task createLibArchive (type: CreateDjArchiveTask) {
    destDir = new File("${buildDir}/lib_infusions")
    archiveFile = "${destDir}/lib_infusions.dja"
}

task createAppArchive (type: CreateDjArchiveTask) {
    destDir = new File("${buildDir}/app_infusion")
    archiveFile = "${destDir}/app_infusion.dja"
}

// TODONR: make this, and other infuser tasks depend on the infuser project
task generateLibinit {
    ext.destDir = new File("${buildDir}/generated-libinit")
    outputs.dir destDir
    outputs.upToDateWhen { return false }
    doLast {
        ensureEmptyDir(destDir)
        ant.generate_libinit(dest: "${destDir}/GENERATED_libinit.c", libDir: "${project.rootDir}/lib", libraries: djConfig.libraries.join(' '))
    }
}

task architectureSpecificAssemble {
    // Can be filled in by architectures
    //  dependsOn assemble, but if I do that here I'll get an error when adding model components...
    //  seems a smelly to me that just touching the assemble task somehow affects the whole project state
    //  such that I can't add components anymore.
}

task darjeeling {
    dependsOn architectureSpecificAssemble
}

// Basic C source sets, excluding libraries and possibly infusions.
model {
    components {
        darjeeling(NativeExecutableSpec) {
            sources {
                core(CSourceSet) {
                    source {
                        srcDir "${project.rootDir}/core/c/common"
                        project.djConfig.getAllPlatforms().each { p ->
                            srcDir "${project.rootDir}/core/c/${p}"
                        }
                        include '**/*.c'
                        srcDir "${project.rootDir}/architecture/${djArchitecture}/c"
                        include '**/*.c'
                    }
                    exportedHeaders {
                        srcDir "${project.rootDir}/core/include/common"
                        project.djConfig.getAllPlatforms().each { p ->
                            srcDir "${project.rootDir}/core/include/${p}"
                        }
                        srcDir "${project.rootDir}/config/${djConfigname}/include"
                        srcDir "${project.rootDir}/architecture/${djArchitecture}/include"
                    }
                }
                main(CSourceSet) {  
                    source {
                        srcDir "${project.rootDir}/config/${djConfigname}/c"
                        include '**/*.c'
                    }
                    lib ( sources['core'] )
                }
                libinit(CSourceSet) {  
                    source {
                        generateLibinit.outputs.getFiles().each { f ->
                            srcDir "${f}"
                        }
                        include '**/*.c'
                        builtBy(generateLibinit)
                    }
                    lib ( sources['core'] )
                }
            }
        }
    }
}

// Load libraries and application
apply from: "djsourceset.gradle"
apply from: "platforms.gradle"
apply from: "architecture-${djArchitecture}.gradle"
def loadDjApp(String name) {
    apply from: "app/${name}/sub.gradle"
    djappsource[name].addTasks()

}
def maybeLoadDjLibrary(String name) {
    if (djlibsource.findByName(name) == null) {
        apply from: "lib/${name}/sub.gradle"
        djlibsource[name].addTasks()
    }
}
// Load any libraries explicitly included in the config (dependencies will be loaded from addTasks())
ext.djConfig.libraries.each { lib ->
    maybeLoadDjLibrary(lib)
}
// And load the application (dependencies will be loaded from addTasks())
loadDjApp(ext.djConfig.app)


architectureSpecificAssemble.dependsOn assemble



