defaultTasks 'darjeelingExecutable'

apply plugin: DarjeelingLibPlugin
apply plugin: 'c'
apply from: "config.gradle"
apply from: "platforms.gradle"
apply from: "architecture-${djArchitecture}.gradle"

apply from: 'core/sub.gradle'
apply from: 'lib/uart/sub.gradle'
apply from: 'lib/wkcomm/sub.gradle'
apply from: 'lib/wkreprog/sub.gradle'
apply from: 'lib/wkpf/sub.gradle'

ext.allPlatforms = []
ext.djPlatform.tokenize('.').each { p ->
    if (allPlatforms.size == 0){
        ext.allPlatforms.add(p)
    } else {
        ext.allPlatforms.add(ext.allPlatforms.last() + '.' + p)
    }
}


def addSourceSet(DjSource djsource) {
    project.model {
        components {
            darjeeling(NativeExecutableSpec) {
                sources.create(djsource.name, CSourceSet) {
                    source {
                        srcDir djsource.basedir + '/c/common'
                        allPlatforms.each { p ->
                            srcDir djsource.basedir + "/c/${p}"
                        }
                        include '**/*.c'
                    }
                    exportedHeaders {
                        srcDir djsource.basedir + '/include/common'
                        allPlatforms.each { p ->
                            srcDir djsource.basedir + "/include/${p}"
                        }
                    }
                    djsource.cDependencies.each { dep ->
                        lib ( sources[dep.name] )
                    }
                    lib ( sources['core'] )

                    if (djsource.cGenerateCodeTask != null) {
                        source {
                            djsource.cGenerateCodeTask.outputs.getFiles().each { f ->
                                srcDir "${f}/c"
                            }
                            include '**/*.c'
                            builtBy (djsource.cGenerateCodeTask) // To create task dependency between the lifecycle task for this source set and the code gen task
                        }
                        exportedHeaders {
                            djsource.cGenerateCodeTask.outputs.getFiles().each { f ->
                                srcDir "${f}/include"
                            }
                        }
                    }
                }
            }
        }
    }   
}

class DarjeelingLibPlugin implements Plugin<Project> {
    void apply(Project project) {
        def djsources = project.container(DjSource)
        djsources.all { djsource ->
            project.afterEvaluate {
                project.addSourceSet(djsource)
            }
        }
        project.extensions.djsources = djsources   
    }
}
class DjSource {
    final String name
    String basedir
    Task cGenerateCodeTask = null
    List<CSourceSet> cDependencies

    DjSource(String name) {
        this.name = name
    }
}



// TODONR: make this, and other infuser tasks depend on the infuser project
task generate_libinit {
    def destDir = new File("${buildDir}/generated-libinit")
    outputs.dir destDir
    outputs.upToDateWhen { return false }
    doLast {
        if (destDir.exists()) {
            destDir.deleteDir()
        }
        destDir.mkdirs()
        ant.taskdef(name: 'generate_libinit',
            classname: 'org.csiro.darjeeling.libinit.ant.LibInitTask',
            classpath: "${projectRoot}/infuser/build/libs/infuser-1.0.jar")
        ant.generate_libinit(dest: "${destDir}/GENERATED_libinit.c", libDir: "${projectRoot}/lib", libraries: djLibraries.join(' '))
    }
}


project.afterEvaluate { // Doing this in after evaluate because otherwise the 'core' sourceset won't exist yet, so libinit can't depend on it.
    project.model {
        components {
            darjeeling(NativeExecutableSpec) {
                sources {
                    main(CSourceSet) {  
                        source {
                            srcDirs "."
                            include 'main.c'
                        }
                    }
                    libinit(CSourceSet) {  
                        source {
                            generate_libinit.outputs.getFiles().each { f ->
                                srcDir "${f}"
                            }
                            include '**/*.c'
                            builtBy(generate_libinit)
                        }
                        lib ( sources['core'] )
                    }
                }
            }
        }
    }
} 
