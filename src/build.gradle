defaultTasks 'darjeeling'
project.ext.djTargetElfFile = "${buildDir}/binaries/darjeeling.elfExecutable/darjeeling.elf"

apply plugin: 'c'
apply from: "djsourceset.gradle"
apply from: "config.gradle"
apply from: "platforms.gradle"
apply from: "architecture-${djArchitecture}.gradle"
apply from: 'taskdefs.gradle'

// We always load all source sets, so we can add required sets even if they're not in the library list, or not in the right order
apply from: 'lib/uart/sub.gradle'
apply from: 'lib/wkcomm/sub.gradle'
apply from: 'lib/wkreprog/sub.gradle'
apply from: 'lib/wkpf/sub.gradle'
apply from: 'lib/vm_dev/sub.gradle'
apply from: 'lib/base/sub.gradle'
apply from: 'lib/vm/sub.gradle'
apply from: 'lib/darjeeling3/sub.gradle'
apply from: 'lib/wkpf_virtual/sub.gradle'
apply from: 'lib/wknode/sub.gradle'
apply from: 'lib/ecocast/sub.gradle'
apply from: 'lib/rtc/sub.gradle'
apply from: 'lib/rtctest2/sub.gradle'
apply from: 'lib/rtctest1/sub.gradle'
apply from: 'lib/rtcbench/sub.gradle'
// Also load the source set for the app we want to build
apply from: "app/${djApp}/sub.gradle"


// Helper functions
def ensureEmptyDir(File destDir) {
    if (destDir.exists()) {
        destDir.deleteDir()
    }
    destDir.mkdirs()
}

// Add dependencies to djLibraries
// (I'm sure this could be prettier...)
while (true) {
    def missing = []
    djLibraries.each { l ->
        djlibsource[l].cDependencies.each { d ->
            if (!(d.name in djLibraries) && !(d.name in missing)) {
                missing.add(d.name)
            }
        }
        djlibsource[l].javaDependencies.each { d ->
            if (!(d.name in djLibraries) && !(d.name in missing)) {
                missing.add(d.name)
            }
        }
    }
    djappsource.first().javaDependencies.each { d ->
        if (!(d.name in djLibraries) && !(d.name in missing)) {
            missing.add(d.name)
        }
    }

    if (missing.isEmpty()) {
        break
    } else {
        missing.each { d ->
            djLibraries.add(0, d)
        }
        missing.clear()
    }
}

// Turn platform into list of directory names to include
// (for example 'arduino.wudevice' becomes ['arduino', 'arduino.wudevice'])
ext.allPlatforms = []
ext.djPlatform.tokenize('.').each { p ->
    if (allPlatforms.size == 0){
        ext.allPlatforms.add(p)
    } else {
        ext.allPlatforms.add(ext.allPlatforms.last() + '.' + p)
    }
}

// TODONR: make this, and other infuser tasks depend on the infuser project
task generateLibinit {
    def destDir = new File("${buildDir}/generated-libinit")
    outputs.dir destDir
    outputs.upToDateWhen { return false }
    doLast {
        ensureEmptyDir(destDir)
        ant.generate_libinit(dest: "${destDir}/GENERATED_libinit.c", libDir: "${projectRoot}/lib", libraries: djLibraries.join(' '))
    }
}


model {
    components {
        'darjeeling.elf'(NativeExecutableSpec) {
            sources {
                core(CSourceSet) {
                    source {
                        srcDir "${projectRoot}/core/c/common"
                        project.allPlatforms.each { p ->
                            srcDir "${projectRoot}/core/c/${p}"
                        }
                        include '**/*.c'
                        srcDir "${projectRoot}/architecture/${djArchitecture}/c"
                        include '**/*.c'
                    }
                    exportedHeaders {
                        srcDir "${projectRoot}/core/include/common"
                        project.allPlatforms.each { p ->
                            srcDir "${projectRoot}/core/include/${p}"
                        }
                        srcDir "${projectRoot}/config/${djConfig}/include"
                        srcDir "${projectRoot}/architecture/${djArchitecture}/include"
                    }
                }
            }
        }
    }
}

task createLibArchive {
    def destDir = new File("${buildDir}/lib_infusions")
    ext.archiveFile = "${destDir}/lib_infusions.dja"
    def libInfusions = []

    djLibraries.each { l ->
        def s = djlibsource[l]
        if (s.sourceSetContainsJavaCode()) {
            inputs.file s.getInfusionFileName() 
            dependsOn s.getInfusionTaskName()
            libInfusions.add s.getInfusionFileName()
        }
    }
    outputs.dir destDir

    doLast {
        ensureEmptyDir(destDir)
        ant.djarchive(dest: archiveFile,
                             src: libInfusions.join(' '),
                             filetype: ant.djarchive_type_lib_infusion,
                             mode: "create")
    }
}

task createAppArchive {
    def destDir = new File("${buildDir}/app_infusion")
    ext.archiveFile = "${destDir}/app_infusion.dja"

    def appDjSource = djappsource.first()
    inputs.file appDjSource.getInfusionFileName() 
    dependsOn appDjSource.getInfusionTaskName()
    outputs.dir destDir

    doLast {
        ensureEmptyDir(destDir)
        ant.djarchive(dest: archiveFile,
                             src: appDjSource.getInfusionFileName(),
                             filetype: ant.djarchive_type_app_infusion,
                             mode: 'create')
    }
}

// Doing this in after evaluate because otherwise the 'core' sourceset won't exist yet,
// so libinit can't depend on it, and the libraries won't exist, so main can't depend on it.
project.afterEvaluate {
    project.model {
        components {
            'darjeeling.elf'(NativeExecutableSpec) {
                sources {
                    main(CSourceSet) {  
                        source {
                            srcDir "${projectRoot}/config/${djConfig}/c"
                            include '**/*.c'
                        }
                        lib ( sources['core'] )
                        djLibraries.each { l ->
                            lib ( sources[l] )
                        }
                    }
                    libinit(CSourceSet) {  
                        source {
                            generateLibinit.outputs.getFiles().each { f ->
                                srcDir "${f}"
                            }
                            include '**/*.c'
                            builtBy(generateLibinit)
                        }
                        lib ( sources['core'] )
                        djlibsource.each { l ->
                            if (l.sourceSetContainsJavaCode() && l.name in djLibraries) {
                                lib ( sources[l.libToInfusionCSourceSetName(l)] )
                            }
                        }
                    }
                }
            }
        }
    }
}

task darjeeling {
    // Architectures should create a task called 'platformSpecificAssemble'
    // which depends on 'assemble', and possibly other platform specific tasks
    dependsOn platformSpecificAssemble
}
