defaultTasks 'darjeeling'
project.ext.djTargetElfFile = "${buildDir}/binaries/darjeeling.elfExecutable/darjeeling.elf"

apply plugin: 'c'
apply from: "djsourceset.gradle"
apply from: "config.gradle"
apply from: "platforms.gradle"
apply from: "architecture-${djArchitecture}.gradle"
apply from: 'taskdefs.gradle'

// We always load all source sets, so we can add required sets even if they're not in the library list, or not in the right order
apply from: 'core/sub.gradle'
apply from: 'lib/uart/sub.gradle'
apply from: 'lib/wkcomm/sub.gradle'
apply from: 'lib/wkreprog/sub.gradle'
apply from: 'lib/wkpf/sub.gradle'
apply from: 'lib/vm_dev/sub.gradle'
apply from: 'lib/base/sub.gradle'
apply from: 'lib/vm/sub.gradle'
apply from: 'lib/darjeeling3/sub.gradle'
apply from: 'lib/wkpf_virtual/sub.gradle'
apply from: 'lib/wknode/sub.gradle'
apply from: 'lib/ecocast/sub.gradle'
apply from: 'lib/rtc/sub.gradle'
apply from: 'lib/rtctest2/sub.gradle'
apply from: 'lib/rtctest1/sub.gradle'
apply from: 'lib/rtcbench/sub.gradle'
// Also load the source set for the app we want to build
apply from: "app/${djApp}/sub.gradle"


// Helper functions
def ensureEmptyDir(File destDir) {
    if (destDir.exists()) {
        destDir.deleteDir()
    }
    destDir.mkdirs()
}

// Add dependencies to djLibraries
// (I'm sure this could be prettier...)
while (true) {
    def missing = []
    djLibraries.each { l ->
        djsources[l].cDependencies.each { d ->
            if (!(d.name in djLibraries) && !(d.name in missing)) {
                missing.add(d.name)
            }
        }
        djsources[l].javaDependencies.each { d ->
            if (!(d.name in djLibraries) && !(d.name in missing)) {
                missing.add(d.name)
            }
        }
    }
    if (missing.isEmpty()) {
        break
    } else {
        missing.each { d ->
            djLibraries.add(0, d)
        }
        missing.clear()
    }
}

// Turn platform into list of directory names to include
// (for example 'arduino.wudevice' becomes ['arduino', 'arduino.wudevice'])
ext.allPlatforms = []
ext.djPlatform.tokenize('.').each { p ->
    if (allPlatforms.size == 0){
        ext.allPlatforms.add(p)
    } else {
        ext.allPlatforms.add(ext.allPlatforms.last() + '.' + p)
    }
}

// TODONR: make this, and other infuser tasks depend on the infuser project
task generateLibinit {
    def destDir = new File("${buildDir}/generated-libinit")
    outputs.dir destDir
    outputs.upToDateWhen { return false }
    doLast {
        ensureEmptyDir(destDir)
        ant.generate_libinit(dest: "${destDir}/GENERATED_libinit.c", libDir: "${projectRoot}/lib", libraries: djLibraries.join(' '))
    }
}

model {
    components {
        'darjeeling.elf'(NativeExecutableSpec) {
            sources {
                config(CSourceSet) { 
                    source { } 
                    exportedHeaders {
                        srcDir "${projectRoot}/config/${djConfig}/include"
                    }
                }
                architecture(CSourceSet) {  
                    source {
                        srcDir "${projectRoot}/architecture/${djArchitecture}/c"
                        include '**/*.c'
                    }
                    exportedHeaders {
                        srcDir "${projectRoot}/architecture/${djArchitecture}/include"
                    }
                }
            }
        }
    }
}

task createLibArchive {
    def destDir = new File("${buildDir}/lib_infusions")
    def archiveFile = "${destDir}/lib_infusions.dja"
    def archiveCFile = "${destDir}/lib_infusion.dja.c"
    def libInfusions = []

    djLibraries.each { l ->
        def s = djsources[l]
        if (s.sourceSetContainsJavaCode()) {
            inputs.file s.getInfusionFileName() 
            dependsOn s.getInfusionTaskName()
            libInfusions.add s.getInfusionFileName()
        }
    }
    outputs.dir destDir

    doLast {
        ensureEmptyDir(destDir)
        def djarchive_type_lib_infusion = 0
        def djarchive_type_app_infusion = 1
        def djarchive_type_wkpf_link_table = 2
        def djarchive_type_wkpf_component_map = 3
        def djarchive_type_wkpf_initvalues = 4
        def djarchive_type_ecocast_capsule_buffer = 5
        ant.djarchive(dest: archiveFile,
                             src: libInfusions.join(' '),
                             filetype: ant.djarchive_type_lib_infusion,
                             mode: "create")
        ant.carray(dest: archiveCFile,
                             src: archiveFile,
                             arrayname: 'di_lib_infusions_archive',
                             arraysize: 0,
                             keywords: "${carray_lib_keywords}")
    }
}

task createAppArchive {
    def destDir = new File("${buildDir}/app_infusion")
    def archiveFile = "${destDir}/app_infusion.dja"
    def archiveCFile = "${destDir}/app_infusiondja.c"

    def appDjSource = djsources[djApp]
    inputs.file appDjSource.getInfusionFileName() 
    dependsOn appDjSource.getInfusionTaskName()
    outputs.dir destDir

    doLast {
        ensureEmptyDir(destDir)
        ant.djarchive(dest: archiveFile,
                             src: appDjSource.getInfusionFileName(),
                             filetype: ant.djarchive_type_app_infusion,
                             mode: 'create')
        ant.carray(dest: archiveCFile,
                             src: archiveFile,
                             arrayname: 'di_app_infusion_archive',
                             arraysize: djAppArchiveSize,
                             keywords: "${carray_app_keywords}")
    }
}

// Doing this in after evaluate because otherwise the 'core' sourceset won't exist yet,
// so libinit can't depend on it, and the libraries won't exist, so main can't depend on it.
project.afterEvaluate {
    project.model {
        components {
            'darjeeling.elf'(NativeExecutableSpec) {
                sources {
                    main(CSourceSet) {  
                        source {
                            srcDir "${projectRoot}/config/${djConfig}/c"
                            include '**/*.c'
                        }
                        lib ( sources['core'] )
                        lib ( sources['config'] )
                        lib ( sources['architecture'] )
                        djLibraries.each { l ->
                            lib ( sources[l] )
                        }
                    }
                    libinit(CSourceSet) {  
                        source {
                            generateLibinit.outputs.getFiles().each { f ->
                                srcDir "${f}"
                            }
                            include '**/*.c'
                            builtBy(generateLibinit)
                        }
                        lib ( sources['core'] )
                        lib ( sources['config'] )
                        lib ( sources['architecture'] )
                        djsources.each { l ->
                            if (l.sourceSetContainsJavaCode() && l.name in djLibraries) {
                                lib ( sources[l.libToInfusionCSourceSetName(l)] )
                            }
                        }
                    }
                    lib_infusions(CSourceSet) {  
                        source {
                            createLibArchive.outputs.getFiles().each { f ->
                                srcDir "${f}"
                            }
                            include '**/*.c'
                            builtBy(createLibArchive)
                        }
                    }
                    app_infusion(CSourceSet) {  
                        source {
                            createAppArchive.outputs.getFiles().each { f ->
                                srcDir "${f}"
                            }
                            include '**/*.c'
                            builtBy(createAppArchive)
                        }
                    }
                }
            }
        }
    }
}

task darjeeling {
    dependsOn platformSpecificAssemble
}
