apply plugin: DjSourceSetPlugin

class DjSourceSetPlugin implements Plugin<Project> {
    void apply(Project project) {
        def djlibsource = project.container(DjLibSourceSet)
        def djappsource = project.container(DjAppSourceSet)
        project.extensions.djlibsource = djlibsource
        project.extensions.djappsource = djappsource
        djlibsource.all { djsource ->
            djsource.init(project)
            project.afterEvaluate {
                // Only add libraries that are enabled
                if (djsource.name in project.ext.djLibraries) {
                    djsource.addTasks()
                }
            }
        }
        djappsource.all { djsource ->
            djsource.init(project)
            project.afterEvaluate {
                // Only the sub.gradle for the current application
                // will be processed, so we can just add it.
                djsource.addTasks()
            }
        }
    }
}

class DjAppSourceSet extends DjSourceSet {
    String wkpfTableXml

    DjAppSourceSet(String name) {
        super(name)
    }
    void init(Project project) {
        super.init(project);
        this.basedir = "${project.projectRoot}/app/${name}"
    }

    def propertyMissing(String name) {
        // This is a bit ugly, but when defining the dependencies
        // for an application, we want to be able to just list something
        // like [ base, vm, wkpf ] instead of using strings.
        if (project.djlibsource.any {n -> n.name==name}) {
            return project.djlibsource[name]
        } else {
            throw new MissingPropertyException("NOT FOUND ${name}")
        }
    }

    void addTasks() {
        super.addTasks()
        if (wkpfTableXml != null) {
            addWkpfTablesToCreateAppArchiveTasks()
        }
    }

    def addWkpfTablesToCreateAppArchiveTasks() {
        def tableXml = new File("${basedir}/${wkpfTableXml}")
        def outputBase = "${project.tasks.createAppArchive.destDir.toString()}/${name}"

        // Not sure if this kind of injection is the proper way in Gradle?
        project.tasks.createAppArchive.inputs.file tableXml
        project.tasks.createAppArchive.doLast {
            ant.wkpftable (
                src: tableXml,
                dest: outputBase
            )

        // Add to existing application dja (containing application Java code)
        ant.djarchive(dest: archiveFile,
                             src: "${outputBase}.wkpf_linktable",
                             filetype: ant.djarchive_type_wkpf_linktable,
                             mode: 'append') // Can change this to 'create' to build a picokong application
        ant.djarchive(dest: archiveFile,
                             src: "${outputBase}.wkpf_componentmap",
                             filetype: ant.djarchive_type_wkpf_componentmap,
                             mode: 'append')
        ant.djarchive(dest: archiveFile,
                             src: "${outputBase}.wkpf_initvalues",
                             filetype: ant.djarchive_type_wkpf_initvalues,
                             mode: 'append')
        }
    }
}

class DjLibSourceSet extends DjSourceSet {
    DjLibSourceSet(String name) {
        super(name)
    }
    void init(Project project) {
        super.init(project);
        this.basedir = "${project.projectRoot}/lib/${name}"
    }
}

class DjSourceSet {
    Project project
    final String name
    String basedir
    Task cGenerateCodeTask = null
    List<DjSourceSet> cDependencies 
    List<DjSourceSet> javaDependencies

    DjSourceSet(String name) {
        this.name = name
    }
    void init (Project project) {
        this.project = project
    }

    boolean sourceSetContainsJavaCode() {
        return new File(this.basedir + '/java').exists()
    }

    void addTasks() {
        println "adding " + this.name
        if (this.sourceSetContainsJavaCode()) {
            this.addJavaTasks()
            this.addJavaCSourceSet()
        }
        this.addCSourceSet()
    }

    String libToJarName(String lib) {
        return "${this.project.buildDir}/${lib}.jar"
    }
    String libToInfusionCSourceSetName(DjSourceSet lib) {
        return "infusion_c_${lib.name}"
    }
    String getInfusionTaskName() {
        return "infusion_${this.name}"
    }
    String libToInfusionDir(DjSourceSet lib) {
        return "${this.project.buildDir}/infusion-${lib.name}"
    }
    String getInfusionDir() {
        return libToInfusionDir(this)
    }
    String getInfusionFileName() {
        return "${this.getInfusionDir()}/${this.name}.di"
    }

    void addJavaTasks() {
        def srcDir = "${this.basedir}/java"
        def outputClassesDir = new File("${project.buildDir}/classes-${this.name}")
        def infusionDir = new File(getInfusionDir())
        def outputJar = libToJarName(this.name)
        def bootclasspath = libToJarName('base')
        def classpath = this.javaDependencies.collect { lib -> libToJarName(lib.name) }.join(':')

        def javac_task = project.tasks.create(name: 'javac_'+this.name) {
            inputs.files project.fileTree(dir: srcDir).include('**/*.java')
            outputs.dir outputClassesDir
            this.javaDependencies.each { jlib ->
                dependsOn("jar_${jlib.name}")
            }
            doLast {
                project.ensureEmptyDir(outputClassesDir)
                ant.javac (
                    srcdir: srcDir,
                    destdir: outputClassesDir,
                    bootclasspath: this.name != 'base' ? bootclasspath : '', // No point in setting a bootclasspath if that's what we're building.
                    classpath: classpath,
                    includeantruntime: false
                )
            }
        }
        def jar_task = project.tasks.create(name: 'jar_'+this.name) {
            dependsOn(javac_task)
            inputs.files project.fileTree(dir: outputClassesDir).include('**/*.class')
            outputs.file outputJar
            doLast {
                ant.jar (destfile: outputJar) {
                    fileset(dir: outputClassesDir, includes: '**/*.class')
                }
            }
        }
        def infusion_task = project.tasks.create(name: this.getInfusionTaskName()) {
            dependsOn(javac_task)
            inputs.files project.fileTree(dir: outputClassesDir).include('**/*.class')
            outputs.dir infusionDir
            this.javaDependencies.each { jlib ->
                dependsOn("infusion_${jlib.name}")
            }
            doLast {
                def infusionheaders = javaDependencies.collect { jlib -> "infusion-${jlib.name}/${jlib.name}.dih"}
                project.ensureEmptyDir(infusionDir)
                ant.infuser(
                        name: this.name,
                        infusionfile: this.getInfusionFileName(),
                        headerfile: "${infusionDir}/${this.name}.dih",
                        hfile: "${infusionDir}/jlib_${this.name}.h",
                        cfile: "${infusionDir}/jlib_${this.name}.c",
                        debugfile: "${infusionDir}/jlib_${this.name}.debug") {
                    fileset(dir: outputClassesDir, includes: '**/*.class')
                    javaDependencies.each { jlib ->
                        fileset(dir: libToInfusionDir(jlib), includes: "${jlib.name}.dih")
                    }
                }
            }
        }
    }
    // No idea why I can't do this in addJavaTasks...
    void addJavaCSourceSet(){
        project.model {
            components {
                'darjeeling.elf'(NativeExecutableSpec) {
                    sources.create(libToInfusionCSourceSetName(this), CSourceSet) {
                        source {
                            srcDir libToInfusionDir(this)
                            include '**/*.c'
                            builtBy(project.tasks[this.getInfusionTaskName()])
                        }
                        exportedHeaders {
                            srcDir libToInfusionDir(this)
                        }
                        lib ( sources['core'] )
                    }
                }
            }
        }
    }

    void addCSourceSet() {
        // Add the source sets to the model
        project.model {
            components {
                'darjeeling.elf'(NativeExecutableSpec) {
                    sources.create(this.name, CSourceSet) {
                        source {
                            srcDir this.basedir + '/c/common'
                            project.allPlatforms.each { p ->
                                srcDir this.basedir + "/c/${p}"
                            }
                            include '**/*.c'
                        }
                        exportedHeaders {
                            srcDir this.basedir + '/include/common'
                            project.allPlatforms.each { p ->
                                srcDir this.basedir + "/include/${p}"
                            }
                        }
                        lib ( sources['core'] )
                        this.cDependencies.each { d ->
                            lib ( sources[d.name] )
                            if (d.sourceSetContainsJavaCode()) {
                                lib ( sources[libToInfusionCSourceSetName(d)] )
                            }
                        }
                        if (this.sourceSetContainsJavaCode()) {
                            lib ( sources[libToInfusionCSourceSetName(this)])
                        }
                        if (this.cGenerateCodeTask != null) {
                            source {
                                this.cGenerateCodeTask.outputs.getFiles().each { f ->
                                    srcDir "${f}/c"
                                }
                                include '**/*.c'
                                builtBy (this.cGenerateCodeTask) // To create task dependency between the lifecycle task for this source set and the code gen task
                            }
                            exportedHeaders {
                                this.cGenerateCodeTask.outputs.getFiles().each { f ->
                                    srcDir "${f}/include"
                                }
                            }
                        }
                    }
                }
            }
        }   
    }
}
